# Relationship Derivation Algorithm

## Overview
The application automatically derives all blood and marriage relationships from explicit parent-child and spouse relationships using graph traversal algorithms.

## Core Algorithm

### 1. Graph Construction
```typescript
interface RelationshipGraph {
  nodes: Map<string, Member>
  edges: Map<string, Relationship[]>
  parentEdges: Map<string, string[]>  // child -> parents
  spouseEdges: Map<string, string[]>  // person -> spouses
}
```

### 2. Blood Relationship Calculation
```typescript
function calculateBloodRelations(memberId: string, graph: RelationshipGraph) {
  const bloodRelations = new Map<string, string>()
  
  // BFS to find all blood relatives
  const queue = [{ id: memberId, distance: 0, path: [] }]
  const visited = new Set<string>()
  
  while (queue.length > 0) {
    const { id, distance, path } = queue.shift()!
    
    if (visited.has(id)) continue
    visited.add(id)
    
    // Add blood relation based on distance and path
    if (distance > 0) {
      const relationType = getBloodRelationType(distance, path)
      bloodRelations.set(id, relationType)
    }
    
    // Add parents to queue
    const parents = graph.parentEdges.get(id) || []
    for (const parentId of parents) {
      queue.push({
        id: parentId,
        distance: distance + 1,
        path: [...path, 'parent']
      })
    }
  }
  
  return bloodRelations
}
```

### 3. Marriage/In-Law Relationship Calculation
```typescript
function calculateInLawRelations(memberId: string, graph: RelationshipGraph) {
  const inLawRelations = new Map<string, string>()
  
  // Find all spouses
  const spouses = graph.spouseEdges.get(memberId) || []
  
  for (const spouseId of spouses) {
    // Parents-in-law: parents of spouse
    const spouseParents = graph.parentEdges.get(spouseId) || []
    for (const parentId of spouseParents) {
      inLawRelations.set(parentId, 'parent-in-law')
    }
    
    // Siblings-in-law: siblings of spouse
    const spouseSiblings = findSiblings(spouseId, graph)
    for (const siblingId of spouseSiblings) {
      inLawRelations.set(siblingId, 'sibling-in-law')
    }
    
    // Children-in-law: children of spouse (from previous relationships)
    const spouseChildren = findChildren(spouseId, graph)
    for (const childId of spouseChildren) {
      inLawRelations.set(childId, 'child-in-law')
    }
  }
  
  return inLawRelations
}
```

## Relationship Types

### Blood Relations (Solid Lines)
- **Siblings**: Share â‰¥1 parent
- **Grandparents**: Parents of parents (distance = 2)
- **Aunts/Uncles**: Siblings of parents
- **Cousins**: Children of siblings
- **Nephews/Nieces**: Children of siblings
- **Great-grandparents**: Parents of grandparents (distance = 3)

### Marriage/In-Law Relations (Dashed Lines)
- **Spouse**: Direct marriage relationship
- **Parents-in-law**: Parents of spouse
- **Siblings-in-law**: Siblings of spouse
- **Children-in-law**: Children of spouse (from other relationships)
- **Grandparents-in-law**: Parents of parents-in-law

## Implementation Patterns

### Relationship Detection Hook
```typescript
export function useRelationships(treeId: string) {
  const [relationships, setRelationships] = useState<DerivedRelationship[]>([])
  
  useEffect(() => {
    if (!treeId) return
    
    const calculateRelationships = async () => {
      const { members, explicitRelationships } = await fetchTreeData(treeId)
      const graph = buildRelationshipGraph(members, explicitRelationships)
      
      const allRelationships: DerivedRelationship[] = []
      
      for (const member of members) {
        const bloodRelations = calculateBloodRelations(member.id, graph)
        const inLawRelations = calculateInLawRelations(member.id, graph)
        
        // Combine and deduplicate
        const memberRelations = new Map([...bloodRelations, ...inLawRelations])
        
        for (const [relatedId, relationType] of memberRelations) {
          allRelationships.push({
            from: member.id,
            to: relatedId,
            type: relationType,
            isInLaw: inLawRelations.has(relatedId)
          })
        }
      }
      
      setRelationships(allRelationships)
    }
    
    calculateRelationships()
  }, [treeId])
  
  return relationships
}
```

### Performance Optimizations
1. **Memoization**: Cache relationship calculations
2. **Incremental Updates**: Recalculate only when relationships change
3. **Lazy Loading**: Calculate relationships on-demand
4. **Web Workers**: Move heavy calculations to background threads

### Edge Cases
1. **Multiple Marriages**: Handle multiple spouses per person
2. **Adoption**: Distinguish between biological and adoptive relationships
3. **Step-Relations**: Handle step-parents and step-siblings
4. **Complex In-Laws**: Extended in-law relationships through multiple marriages
description:
globs:
alwaysApply: false
---
